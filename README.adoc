= Lightweight Markup Languages
Writer <duncan.attard.01@um.edu.mt>
v0.9, 04-05-2020 // Star Wars Day ^_^
:appversion: 0.9

:stem: latexmath
:icons: font
:source-highlighter: highlightjs
:toc:
:toc-placement!:
//:sectnums:



// Github-specific styling.
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

// Shields.
image::https://img.shields.io/badge/license-GPLv3-blue[link="https://www.gnu.org/licenses/gpl-3.0"]
image::https://img.shields.io/badge/version-v0.9-yellow[]

`detectEr` is an inline monitoring tool that synthesised runtime monitors from correctness properties specified in syntactic subset of Hennessy-Milner Logic with recursion that is in its _normal form_ (HML__nf__).
//
`detectEr` assumes access to the source code of the program to be monitored.
//
It instruments monitoring instructions into the target program via _code injection_ by manipulating its parsed abstract syntax tree.
//
The modified syntax tree is compiled by `detectEr` into an executable form which can then be run normally.
//
The instrumented instructions perform the runtime analysis in _synchronous_ fashion as the program executes.
//
Our tool is developed in the Erlang language and for the Erlang eco-system.

toc::[]


== Overview

Correctness properties in `detectEr` are scripted in plain text format using SHML~nf~ syntax.
//
These are then parsed, and the corresponding executable runtime monitor is synthesised in its source or binary form.
//
The resulting file bears the name of the properties script, and contains one function, `mfa_spec`, that encapsulates all the monitoring logic.


=== Script file

More than one property may be specified in a single script file, albeit separated by commas `,`; the last one must be terminated with a period `.`.
//
A specification must target _one_ Erlang function pattern, and may optionally include simple _guard statements_.
//
The guard specification format follows the one used by Erlang, the only difference being that guard functions (_e.g._ `is_pid/1`, `is_alive/1`, _etc._) are currently not supported.
//
Patterns and guards on Erlang binaries, bitstrings and maps will be implemented in future releases.
//
Specifications can only target function calls, _i.e._, `Mod:Fun(Args)`, that have been exported from Erlang modules and invoked via `erlang:spawn/3` or `erlang:spawn/4`.

.{zwsp}
====
The function `test` in module `example` takes two parameters, `A` and `B`, where `A` is an integer in the closed interval [0, 10].
//
A property specification that targets the function `test` is specified as follows:

[subs="quotes"]
----
*with*
  example:test(A, B) when A >= 0, A =< 10
*monitor*
  _property in SHML~nf~_.
----
====

The property itself, `_property in SHMLnf_`, is written using the grammar defined next.


=== The SHML~nf~ grammar

The SHML~nf~ grammar is defined by the following BNF:

[subs="quotes"]
----
<SHML~nf~> ::= *ff*  <1>
          | _X_  <2>
          | max(_X_. <SHML~nf~>)  <3>
          | and(<SHML~nf~ list>).  <4>
----
<1> Falsity, an atom
<2> Recursion variable specified as a standard Erlang variable
<3> Maximal fix-point that specify recursive loops comprised of one variable and the sub-formula `<SHML~nf~>`
<4> A sequence of comma-separated *conjuncts* where each conjunct is a sub-formula `<SHML~nf~>` that starts with a necessity `[<ACTION>]<SHML~nf~>`

A necessity, specified by `[]` contains the `<ACTION>` that is matched with the trace event exhibited by the system.
//
Matching is performed both on the type of action as well as the data it carries in relation to the trace event.
//
There are five actions types:
//
[horizontal]
Fork:: Process creation action, specified as `PID~p~ -> PID~c~, M:F(A)`. This action is exhibited by the parent process invoking fork.
Forked:: Process initialisation action, specified as `PID~p~ <- PID~c~, M:F(A)`. This action is exhibited by the child process that has been forked.
Exit:: Process termination action, specified as `PID ** CLAUSE`.
Send:: Process send action, specified as `PID ! CLAUSE`.
Receive:: Process receive action, specified as `PID ? CLAUSE`.
Any:: Generic user-given process action, specified as `CLAUSE`.

where `PID` is a generic Erlang variable that binds to a process ID (PID).
//
`PID~p~` denotes the PID of the parent process and `PID~c~`, the PID of the child (forked) process.
//
`M:F(A)` denotes the function that was forked to execute in its own independent process: the variable `M` binds to the name of the _module_ where the function resides, `F`, to the forked _function_, and `A`, binds to the _arguments_ specified in `F`.
//
`CLAUSE` represents a standard Erlang clause that may in turn contain generic data variables.
//
Actions inside the necessity construct `[]` may optionally include guards, albeit with the restrictions mentioned above.

The following are some examples of scripted HML~nf~ properties.

.{zwsp}
====
This property checks that the parent process does not fork child processes with negative IDs.
//
The property below reads as: "the parent process `P` cannot fork a child process `C` via the function `child:init(Id, StartCnt)` such that the `Id` assigned is negative".

[subs="quotes"]
----
*with*
  parent:start()
*monitor*
    and([P -> C, child:init([Id, _]) when Id < 0] *ff*).
----
//
The falsity `*ff*` states that when the necessity `[P -> C, child:init([Id, pass:[_]]) when Id < 0]` matches such a fork event, a _violation_ is flagged.
//
We use the Erlang anonymous variable `_` to bind `StartCnt` since this value is unimportant.
====


.{zwsp}
====
This property checks that the parent process does not fork a child process and terminates immediately after with the reason `aborted`.
//
The property below reads as: "the parent process `P` cannot fork a child process `C` via the function `child:init(Id, StartCnt)` and terminate immediately with the reason `aborted` ".

[subs="quotes,macros"]
----
*with*
  parent:start()
*monitor*
  and([P -> C, child:init([_, _])] and([P pass:[**] aborted] *ff*)).
----
//
The outer `and(...)` construct consists of a *single necessity* that binds the action `P -> C, child:init([pass:[_], pass:[_]])` to the fork event exhibited by `P`.
//
Similarly, the inner `and(...)` binds the only necessity `[P ** aborted]` to the termination event exhibited by `P`.
//
We remark that, following the SHML~nf~ grammar given above, nesting `and` constructs, _i.e._, `and([...] and([...], ...))`, enables us to encode necessity _sequences_.
====


== Sample System


We include a source code sample that models a simple client-server interaction.
//
This sample can be found under the `/src/system` directory.
//
The server (`server.erl`) exposes two functions, start and stop, that are used to launch and terminate the server process.
//
It also implements three operations described below:
//
[cols=3*,options=header]
|===
|Operation |Request |Description
|stop | `{From, Ref, stop}` | Server stop request
|add | `{From, Ref, {add, A, B}}` | Addition request
|multiply | `{From, Ref, {mul, A, B}}` | Multiplication request
|===
//
The variables `From` and `Ref` bind to the PID of the sender process and reference respectively; `A` and `B` bind to the numbers that are operated upon.
//
`Ref` is used for internal implementation purposes, and is unimportant in what follows.
//
The function `stop/1` exposed by the `server` module sends a `stop` request to the server process to terminate it.
//
Our server is started and stopped as follows:

[source,erlang]
----
server:start(ok).
server:stop().
----







//
The client (`client.erl`) exposes two remote invocation stubs that correspond to the operations add and multiply from the `server` module.







.{zwsp}
====


====






% Server process S can engage in a request-response cycle such that it
% receives a request @{req, A1, A2@} consisting of two integers A1 and A2,
% returning the result of their addition in the response @{resp, AA@}. It
% however cannot return something other than their addition: this is taken
% care of by the second necessity in the second conjunct via the action
% clause @{resp, AA@} when AA =/= A1 + A2.
with
example:test(A, B) when A >= 0, A =< 10
monitor
max(X.
and(
[S ? @{req, A1, A2@}] and(
[S ! @{resp, AA@} when AA =/= A1 + A2]ff,
[S ! @{resp, AA@} when AA =:= A1 + A2]X)
)
)
).


with
server:loop(_)
monitor
and([_Launcher <- _Server, server:loop(_)]
max(X.
and(
[_Server ? {_, _, {add, A, B}}] and(
[_Server ! {_, {add, AB}} when AB =/= A + B]ff,
[_Server ! {_, {add, AB}} when AB =:= A + B]X
),
[_Server ? {_, _, {_, _, _}}] and(
[_Server ! {_, {_, _}}]X
),
[_Server ? {_, _, stop}] and(
[_Server ! {_, {ok, stopped}}]X
)
)
)
).




















== Stuff
.Possible DefOps manual locations
* West wood maze
** Maze heart
*** Reflection pool
** Secret exit
* Untracked file in git repository


. Protons
. Electrons
. Neutrons


CPU:: The brain of the computer.
Hard drive:: Permanent storage for operating system and/or user files.
RAM:: Temporarily stores information the CPU uses during operation.
Keyboard:: Used to enter text or control items on the screen.
Mouse:: Used to point to and select items on your computer screen.
Monitor:: Displays information in visual form using text and graphics.


[horizontal]
CPU:: The brain of the computer.
Hard drive:: Permanent storage for operating system and/or user files.
RAM:: Temporarily stores information the CPU uses during operation.


* The header in AsciiDoc must start with a document title.
+
The header is optional.


----
This is an example of a _listing block_.
The content inside is displayed as <pre> text.
----

====
Example
====

____
Verse
____

****
Sidebar
****

[cols=2*,options=header]
|===
|Name |Group

|Firefox |Web Browser

|Ruby |Programming Language
|===


stem:[\sqrt4 = 2]

Water (stem:[H_2O]) is a critical component.

stem:[\langle \mu\rangle]


[TIP]

Duncan